// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: 1100000_UserMessage.proto

#ifndef PROTOBUF_1100000_5fUserMessage_2eproto__INCLUDED
#define PROTOBUF_1100000_5fUserMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

class UserIdBean;
class UserInfoBean;
class UserLoginUp;
class UserLoginDown;
class UserLogoutUp;
class GetUserinfoUp;
class GetUserinfoDown;
class ChangeUserNameUp;
class ChangeUserIconUp;
class ChangeUserStateUp;

enum UserCommondIdEnum {
  _UserLoginUp = 1100003,
  _UserLoginDown = 1100004,
  _UserLogoutUp = 1100005,
  _GetUserinfoUp = 1100007,
  _GetUserinfoDown = 1100008,
  _ChangeUserNameUp = 1100009,
  _ChangeUserIconUp = 1100011,
  _ChangeUserStateUp = 1100013
};
bool UserCommondIdEnum_IsValid(int value);
const UserCommondIdEnum UserCommondIdEnum_MIN = _UserLoginUp;
const UserCommondIdEnum UserCommondIdEnum_MAX = _ChangeUserStateUp;
const int UserCommondIdEnum_ARRAYSIZE = UserCommondIdEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserCommondIdEnum_descriptor();
inline const ::std::string& UserCommondIdEnum_Name(UserCommondIdEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserCommondIdEnum_descriptor(), value);
}
inline bool UserCommondIdEnum_Parse(
    const ::std::string& name, UserCommondIdEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserCommondIdEnum>(
    UserCommondIdEnum_descriptor(), name, value);
}
// ===================================================================

class UserIdBean : public ::google::protobuf::Message {
 public:
  UserIdBean();
  virtual ~UserIdBean();

  UserIdBean(const UserIdBean& from);

  inline UserIdBean& operator=(const UserIdBean& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserIdBean& default_instance();

  void Swap(UserIdBean* other);

  // implements Message ----------------------------------------------

  UserIdBean* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserIdBean& from);
  void MergeFrom(const UserIdBean& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string createTime = 2;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 2;
  inline const ::std::string& createtime() const;
  inline void set_createtime(const ::std::string& value);
  inline void set_createtime(const char* value);
  inline void set_createtime(const char* value, size_t size);
  inline ::std::string* mutable_createtime();
  inline ::std::string* release_createtime();
  inline void set_allocated_createtime(::std::string* createtime);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserIdBean)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* createtime_;
  ::std::string* name_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static UserIdBean* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoBean : public ::google::protobuf::Message {
 public:
  UserInfoBean();
  virtual ~UserInfoBean();

  UserInfoBean(const UserInfoBean& from);

  inline UserInfoBean& operator=(const UserInfoBean& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoBean& default_instance();

  void Swap(UserInfoBean* other);

  // implements Message ----------------------------------------------

  UserInfoBean* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoBean& from);
  void MergeFrom(const UserInfoBean& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 experience = 3;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 3;
  inline ::google::protobuf::uint32 experience() const;
  inline void set_experience(::google::protobuf::uint32 value);

  // required uint32 icon = 4;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 4;
  inline ::google::protobuf::uint32 icon() const;
  inline void set_icon(::google::protobuf::uint32 value);

  // required uint32 power = 5;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 5;
  inline ::google::protobuf::uint32 power() const;
  inline void set_power(::google::protobuf::uint32 value);

  // required uint32 modifyNameCount = 6;
  inline bool has_modifynamecount() const;
  inline void clear_modifynamecount();
  static const int kModifyNameCountFieldNumber = 6;
  inline ::google::protobuf::uint32 modifynamecount() const;
  inline void set_modifynamecount(::google::protobuf::uint32 value);

  // required string eventState = 7;
  inline bool has_eventstate() const;
  inline void clear_eventstate();
  static const int kEventStateFieldNumber = 7;
  inline const ::std::string& eventstate() const;
  inline void set_eventstate(const ::std::string& value);
  inline void set_eventstate(const char* value);
  inline void set_eventstate(const char* value, size_t size);
  inline ::std::string* mutable_eventstate();
  inline ::std::string* release_eventstate();
  inline void set_allocated_eventstate(::std::string* eventstate);

  // required string functionState = 8;
  inline bool has_functionstate() const;
  inline void clear_functionstate();
  static const int kFunctionStateFieldNumber = 8;
  inline const ::std::string& functionstate() const;
  inline void set_functionstate(const ::std::string& value);
  inline void set_functionstate(const char* value);
  inline void set_functionstate(const char* value, size_t size);
  inline ::std::string* mutable_functionstate();
  inline ::std::string* release_functionstate();
  inline void set_allocated_functionstate(::std::string* functionstate);

  // required uint32 lucky = 9;
  inline bool has_lucky() const;
  inline void clear_lucky();
  static const int kLuckyFieldNumber = 9;
  inline ::google::protobuf::uint32 lucky() const;
  inline void set_lucky(::google::protobuf::uint32 value);

  // required uint32 currentState = 10;
  inline bool has_currentstate() const;
  inline void clear_currentstate();
  static const int kCurrentStateFieldNumber = 10;
  inline ::google::protobuf::uint32 currentstate() const;
  inline void set_currentstate(::google::protobuf::uint32 value);

  // required uint32 buyPowerCount = 11;
  inline bool has_buypowercount() const;
  inline void clear_buypowercount();
  static const int kBuyPowerCountFieldNumber = 11;
  inline ::google::protobuf::uint32 buypowercount() const;
  inline void set_buypowercount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserInfoBean)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_experience();
  inline void clear_has_experience();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_modifynamecount();
  inline void clear_has_modifynamecount();
  inline void set_has_eventstate();
  inline void clear_has_eventstate();
  inline void set_has_functionstate();
  inline void clear_has_functionstate();
  inline void set_has_lucky();
  inline void clear_has_lucky();
  inline void set_has_currentstate();
  inline void clear_has_currentstate();
  inline void set_has_buypowercount();
  inline void clear_has_buypowercount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 experience_;
  ::google::protobuf::uint32 icon_;
  ::google::protobuf::uint32 power_;
  ::std::string* eventstate_;
  ::google::protobuf::uint32 modifynamecount_;
  ::google::protobuf::uint32 lucky_;
  ::std::string* functionstate_;
  ::google::protobuf::uint32 currentstate_;
  ::google::protobuf::uint32 buypowercount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static UserInfoBean* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginUp : public ::google::protobuf::Message {
 public:
  UserLoginUp();
  virtual ~UserLoginUp();

  UserLoginUp(const UserLoginUp& from);

  inline UserLoginUp& operator=(const UserLoginUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginUp& default_instance();

  void Swap(UserLoginUp* other);

  // implements Message ----------------------------------------------

  UserLoginUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLoginUp& from);
  void MergeFrom(const UserLoginUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required uint32 rid = 2;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRidFieldNumber = 2;
  inline ::google::protobuf::uint32 rid() const;
  inline void set_rid(::google::protobuf::uint32 value);

  // required string userIdStr = 3;
  inline bool has_useridstr() const;
  inline void clear_useridstr();
  static const int kUserIdStrFieldNumber = 3;
  inline const ::std::string& useridstr() const;
  inline void set_useridstr(const ::std::string& value);
  inline void set_useridstr(const char* value);
  inline void set_useridstr(const char* value, size_t size);
  inline ::std::string* mutable_useridstr();
  inline ::std::string* release_useridstr();
  inline void set_allocated_useridstr(::std::string* useridstr);

  // required uint32 asid = 4;
  inline bool has_asid() const;
  inline void clear_asid();
  static const int kAsidFieldNumber = 4;
  inline ::google::protobuf::uint32 asid() const;
  inline void set_asid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserLoginUp)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_useridstr();
  inline void clear_has_useridstr();
  inline void set_has_asid();
  inline void clear_has_asid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* useridstr_;
  ::google::protobuf::uint32 rid_;
  ::google::protobuf::uint32 asid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static UserLoginUp* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginDown : public ::google::protobuf::Message {
 public:
  UserLoginDown();
  virtual ~UserLoginDown();

  UserLoginDown(const UserLoginDown& from);

  inline UserLoginDown& operator=(const UserLoginDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginDown& default_instance();

  void Swap(UserLoginDown* other);

  // implements Message ----------------------------------------------

  UserLoginDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLoginDown& from);
  void MergeFrom(const UserLoginDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 loginState = 1;
  inline bool has_loginstate() const;
  inline void clear_loginstate();
  static const int kLoginStateFieldNumber = 1;
  inline ::google::protobuf::uint32 loginstate() const;
  inline void set_loginstate(::google::protobuf::uint32 value);

  // required string logoutTime = 2;
  inline bool has_logouttime() const;
  inline void clear_logouttime();
  static const int kLogoutTimeFieldNumber = 2;
  inline const ::std::string& logouttime() const;
  inline void set_logouttime(const ::std::string& value);
  inline void set_logouttime(const char* value);
  inline void set_logouttime(const char* value, size_t size);
  inline ::std::string* mutable_logouttime();
  inline ::std::string* release_logouttime();
  inline void set_allocated_logouttime(::std::string* logouttime);

  // @@protoc_insertion_point(class_scope:UserLoginDown)
 private:
  inline void set_has_loginstate();
  inline void clear_has_loginstate();
  inline void set_has_logouttime();
  inline void clear_has_logouttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* logouttime_;
  ::google::protobuf::uint32 loginstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static UserLoginDown* default_instance_;
};
// -------------------------------------------------------------------

class UserLogoutUp : public ::google::protobuf::Message {
 public:
  UserLogoutUp();
  virtual ~UserLogoutUp();

  UserLogoutUp(const UserLogoutUp& from);

  inline UserLogoutUp& operator=(const UserLogoutUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogoutUp& default_instance();

  void Swap(UserLogoutUp* other);

  // implements Message ----------------------------------------------

  UserLogoutUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserLogoutUp& from);
  void MergeFrom(const UserLogoutUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:UserLogoutUp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static UserLogoutUp* default_instance_;
};
// -------------------------------------------------------------------

class GetUserinfoUp : public ::google::protobuf::Message {
 public:
  GetUserinfoUp();
  virtual ~GetUserinfoUp();

  GetUserinfoUp(const GetUserinfoUp& from);

  inline GetUserinfoUp& operator=(const GetUserinfoUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserinfoUp& default_instance();

  void Swap(GetUserinfoUp* other);

  // implements Message ----------------------------------------------

  GetUserinfoUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserinfoUp& from);
  void MergeFrom(const GetUserinfoUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:GetUserinfoUp)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static GetUserinfoUp* default_instance_;
};
// -------------------------------------------------------------------

class GetUserinfoDown : public ::google::protobuf::Message {
 public:
  GetUserinfoDown();
  virtual ~GetUserinfoDown();

  GetUserinfoDown(const GetUserinfoDown& from);

  inline GetUserinfoDown& operator=(const GetUserinfoDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserinfoDown& default_instance();

  void Swap(GetUserinfoDown* other);

  // implements Message ----------------------------------------------

  GetUserinfoDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserinfoDown& from);
  void MergeFrom(const GetUserinfoDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required .UserInfoBean userInfoBean = 2;
  inline bool has_userinfobean() const;
  inline void clear_userinfobean();
  static const int kUserInfoBeanFieldNumber = 2;
  inline const ::UserInfoBean& userinfobean() const;
  inline ::UserInfoBean* mutable_userinfobean();
  inline ::UserInfoBean* release_userinfobean();
  inline void set_allocated_userinfobean(::UserInfoBean* userinfobean);

  // @@protoc_insertion_point(class_scope:GetUserinfoDown)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_userinfobean();
  inline void clear_has_userinfobean();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::UserInfoBean* userinfobean_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static GetUserinfoDown* default_instance_;
};
// -------------------------------------------------------------------

class ChangeUserNameUp : public ::google::protobuf::Message {
 public:
  ChangeUserNameUp();
  virtual ~ChangeUserNameUp();

  ChangeUserNameUp(const ChangeUserNameUp& from);

  inline ChangeUserNameUp& operator=(const ChangeUserNameUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeUserNameUp& default_instance();

  void Swap(ChangeUserNameUp* other);

  // implements Message ----------------------------------------------

  ChangeUserNameUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeUserNameUp& from);
  void MergeFrom(const ChangeUserNameUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:ChangeUserNameUp)
 private:
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static ChangeUserNameUp* default_instance_;
};
// -------------------------------------------------------------------

class ChangeUserIconUp : public ::google::protobuf::Message {
 public:
  ChangeUserIconUp();
  virtual ~ChangeUserIconUp();

  ChangeUserIconUp(const ChangeUserIconUp& from);

  inline ChangeUserIconUp& operator=(const ChangeUserIconUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeUserIconUp& default_instance();

  void Swap(ChangeUserIconUp* other);

  // implements Message ----------------------------------------------

  ChangeUserIconUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeUserIconUp& from);
  void MergeFrom(const ChangeUserIconUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 icon = 1;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 1;
  inline ::google::protobuf::uint32 icon() const;
  inline void set_icon(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ChangeUserIconUp)
 private:
  inline void set_has_icon();
  inline void clear_has_icon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 icon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static ChangeUserIconUp* default_instance_;
};
// -------------------------------------------------------------------

class ChangeUserStateUp : public ::google::protobuf::Message {
 public:
  ChangeUserStateUp();
  virtual ~ChangeUserStateUp();

  ChangeUserStateUp(const ChangeUserStateUp& from);

  inline ChangeUserStateUp& operator=(const ChangeUserStateUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeUserStateUp& default_instance();

  void Swap(ChangeUserStateUp* other);

  // implements Message ----------------------------------------------

  ChangeUserStateUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeUserStateUp& from);
  void MergeFrom(const ChangeUserStateUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string eventState = 1;
  inline bool has_eventstate() const;
  inline void clear_eventstate();
  static const int kEventStateFieldNumber = 1;
  inline const ::std::string& eventstate() const;
  inline void set_eventstate(const ::std::string& value);
  inline void set_eventstate(const char* value);
  inline void set_eventstate(const char* value, size_t size);
  inline ::std::string* mutable_eventstate();
  inline ::std::string* release_eventstate();
  inline void set_allocated_eventstate(::std::string* eventstate);

  // required string functionState = 2;
  inline bool has_functionstate() const;
  inline void clear_functionstate();
  static const int kFunctionStateFieldNumber = 2;
  inline const ::std::string& functionstate() const;
  inline void set_functionstate(const ::std::string& value);
  inline void set_functionstate(const char* value);
  inline void set_functionstate(const char* value, size_t size);
  inline ::std::string* mutable_functionstate();
  inline ::std::string* release_functionstate();
  inline void set_allocated_functionstate(::std::string* functionstate);

  // @@protoc_insertion_point(class_scope:ChangeUserStateUp)
 private:
  inline void set_has_eventstate();
  inline void clear_has_eventstate();
  inline void set_has_functionstate();
  inline void clear_has_functionstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventstate_;
  ::std::string* functionstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_AssignDesc_1100000_5fUserMessage_2eproto();
  friend void protobuf_ShutdownFile_1100000_5fUserMessage_2eproto();

  void InitAsDefaultInstance();
  static ChangeUserStateUp* default_instance_;
};
// ===================================================================


// ===================================================================

// UserIdBean

// required string userId = 1;
inline bool UserIdBean::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserIdBean::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserIdBean::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserIdBean::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& UserIdBean::userid() const {
  return *userid_;
}
inline void UserIdBean::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserIdBean::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserIdBean::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserIdBean::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* UserIdBean::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserIdBean::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string createTime = 2;
inline bool UserIdBean::has_createtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserIdBean::set_has_createtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserIdBean::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserIdBean::clear_createtime() {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    createtime_->clear();
  }
  clear_has_createtime();
}
inline const ::std::string& UserIdBean::createtime() const {
  return *createtime_;
}
inline void UserIdBean::set_createtime(const ::std::string& value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void UserIdBean::set_createtime(const char* value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void UserIdBean::set_createtime(const char* value, size_t size) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserIdBean::mutable_createtime() {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  return createtime_;
}
inline ::std::string* UserIdBean::release_createtime() {
  clear_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createtime_;
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserIdBean::set_allocated_createtime(::std::string* createtime) {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    delete createtime_;
  }
  if (createtime) {
    set_has_createtime();
    createtime_ = createtime;
  } else {
    clear_has_createtime();
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool UserIdBean::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserIdBean::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserIdBean::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserIdBean::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserIdBean::name() const {
  return *name_;
}
inline void UserIdBean::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserIdBean::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserIdBean::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserIdBean::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserIdBean::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserIdBean::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 level = 4;
inline bool UserIdBean::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserIdBean::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserIdBean::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserIdBean::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 UserIdBean::level() const {
  return level_;
}
inline void UserIdBean::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// UserInfoBean

// required string name = 1;
inline bool UserInfoBean::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoBean::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoBean::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoBean::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserInfoBean::name() const {
  return *name_;
}
inline void UserInfoBean::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserInfoBean::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserInfoBean::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoBean::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserInfoBean::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoBean::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 level = 2;
inline bool UserInfoBean::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoBean::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoBean::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoBean::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 UserInfoBean::level() const {
  return level_;
}
inline void UserInfoBean::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 experience = 3;
inline bool UserInfoBean::has_experience() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoBean::set_has_experience() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoBean::clear_has_experience() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoBean::clear_experience() {
  experience_ = 0u;
  clear_has_experience();
}
inline ::google::protobuf::uint32 UserInfoBean::experience() const {
  return experience_;
}
inline void UserInfoBean::set_experience(::google::protobuf::uint32 value) {
  set_has_experience();
  experience_ = value;
}

// required uint32 icon = 4;
inline bool UserInfoBean::has_icon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoBean::set_has_icon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoBean::clear_has_icon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoBean::clear_icon() {
  icon_ = 0u;
  clear_has_icon();
}
inline ::google::protobuf::uint32 UserInfoBean::icon() const {
  return icon_;
}
inline void UserInfoBean::set_icon(::google::protobuf::uint32 value) {
  set_has_icon();
  icon_ = value;
}

// required uint32 power = 5;
inline bool UserInfoBean::has_power() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfoBean::set_has_power() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfoBean::clear_has_power() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfoBean::clear_power() {
  power_ = 0u;
  clear_has_power();
}
inline ::google::protobuf::uint32 UserInfoBean::power() const {
  return power_;
}
inline void UserInfoBean::set_power(::google::protobuf::uint32 value) {
  set_has_power();
  power_ = value;
}

// required uint32 modifyNameCount = 6;
inline bool UserInfoBean::has_modifynamecount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfoBean::set_has_modifynamecount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfoBean::clear_has_modifynamecount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfoBean::clear_modifynamecount() {
  modifynamecount_ = 0u;
  clear_has_modifynamecount();
}
inline ::google::protobuf::uint32 UserInfoBean::modifynamecount() const {
  return modifynamecount_;
}
inline void UserInfoBean::set_modifynamecount(::google::protobuf::uint32 value) {
  set_has_modifynamecount();
  modifynamecount_ = value;
}

// required string eventState = 7;
inline bool UserInfoBean::has_eventstate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfoBean::set_has_eventstate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfoBean::clear_has_eventstate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfoBean::clear_eventstate() {
  if (eventstate_ != &::google::protobuf::internal::kEmptyString) {
    eventstate_->clear();
  }
  clear_has_eventstate();
}
inline const ::std::string& UserInfoBean::eventstate() const {
  return *eventstate_;
}
inline void UserInfoBean::set_eventstate(const ::std::string& value) {
  set_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    eventstate_ = new ::std::string;
  }
  eventstate_->assign(value);
}
inline void UserInfoBean::set_eventstate(const char* value) {
  set_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    eventstate_ = new ::std::string;
  }
  eventstate_->assign(value);
}
inline void UserInfoBean::set_eventstate(const char* value, size_t size) {
  set_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    eventstate_ = new ::std::string;
  }
  eventstate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoBean::mutable_eventstate() {
  set_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    eventstate_ = new ::std::string;
  }
  return eventstate_;
}
inline ::std::string* UserInfoBean::release_eventstate() {
  clear_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventstate_;
    eventstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoBean::set_allocated_eventstate(::std::string* eventstate) {
  if (eventstate_ != &::google::protobuf::internal::kEmptyString) {
    delete eventstate_;
  }
  if (eventstate) {
    set_has_eventstate();
    eventstate_ = eventstate;
  } else {
    clear_has_eventstate();
    eventstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string functionState = 8;
inline bool UserInfoBean::has_functionstate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfoBean::set_has_functionstate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfoBean::clear_has_functionstate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfoBean::clear_functionstate() {
  if (functionstate_ != &::google::protobuf::internal::kEmptyString) {
    functionstate_->clear();
  }
  clear_has_functionstate();
}
inline const ::std::string& UserInfoBean::functionstate() const {
  return *functionstate_;
}
inline void UserInfoBean::set_functionstate(const ::std::string& value) {
  set_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    functionstate_ = new ::std::string;
  }
  functionstate_->assign(value);
}
inline void UserInfoBean::set_functionstate(const char* value) {
  set_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    functionstate_ = new ::std::string;
  }
  functionstate_->assign(value);
}
inline void UserInfoBean::set_functionstate(const char* value, size_t size) {
  set_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    functionstate_ = new ::std::string;
  }
  functionstate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoBean::mutable_functionstate() {
  set_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    functionstate_ = new ::std::string;
  }
  return functionstate_;
}
inline ::std::string* UserInfoBean::release_functionstate() {
  clear_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = functionstate_;
    functionstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoBean::set_allocated_functionstate(::std::string* functionstate) {
  if (functionstate_ != &::google::protobuf::internal::kEmptyString) {
    delete functionstate_;
  }
  if (functionstate) {
    set_has_functionstate();
    functionstate_ = functionstate;
  } else {
    clear_has_functionstate();
    functionstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 lucky = 9;
inline bool UserInfoBean::has_lucky() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfoBean::set_has_lucky() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfoBean::clear_has_lucky() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfoBean::clear_lucky() {
  lucky_ = 0u;
  clear_has_lucky();
}
inline ::google::protobuf::uint32 UserInfoBean::lucky() const {
  return lucky_;
}
inline void UserInfoBean::set_lucky(::google::protobuf::uint32 value) {
  set_has_lucky();
  lucky_ = value;
}

// required uint32 currentState = 10;
inline bool UserInfoBean::has_currentstate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfoBean::set_has_currentstate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfoBean::clear_has_currentstate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfoBean::clear_currentstate() {
  currentstate_ = 0u;
  clear_has_currentstate();
}
inline ::google::protobuf::uint32 UserInfoBean::currentstate() const {
  return currentstate_;
}
inline void UserInfoBean::set_currentstate(::google::protobuf::uint32 value) {
  set_has_currentstate();
  currentstate_ = value;
}

// required uint32 buyPowerCount = 11;
inline bool UserInfoBean::has_buypowercount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfoBean::set_has_buypowercount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfoBean::clear_has_buypowercount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfoBean::clear_buypowercount() {
  buypowercount_ = 0u;
  clear_has_buypowercount();
}
inline ::google::protobuf::uint32 UserInfoBean::buypowercount() const {
  return buypowercount_;
}
inline void UserInfoBean::set_buypowercount(::google::protobuf::uint32 value) {
  set_has_buypowercount();
  buypowercount_ = value;
}

// -------------------------------------------------------------------

// UserLoginUp

// required string token = 1;
inline bool UserLoginUp::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginUp::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginUp::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginUp::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserLoginUp::token() const {
  return *token_;
}
inline void UserLoginUp::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserLoginUp::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserLoginUp::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginUp::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* UserLoginUp::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginUp::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 rid = 2;
inline bool UserLoginUp::has_rid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginUp::set_has_rid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginUp::clear_has_rid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginUp::clear_rid() {
  rid_ = 0u;
  clear_has_rid();
}
inline ::google::protobuf::uint32 UserLoginUp::rid() const {
  return rid_;
}
inline void UserLoginUp::set_rid(::google::protobuf::uint32 value) {
  set_has_rid();
  rid_ = value;
}

// required string userIdStr = 3;
inline bool UserLoginUp::has_useridstr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLoginUp::set_has_useridstr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLoginUp::clear_has_useridstr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLoginUp::clear_useridstr() {
  if (useridstr_ != &::google::protobuf::internal::kEmptyString) {
    useridstr_->clear();
  }
  clear_has_useridstr();
}
inline const ::std::string& UserLoginUp::useridstr() const {
  return *useridstr_;
}
inline void UserLoginUp::set_useridstr(const ::std::string& value) {
  set_has_useridstr();
  if (useridstr_ == &::google::protobuf::internal::kEmptyString) {
    useridstr_ = new ::std::string;
  }
  useridstr_->assign(value);
}
inline void UserLoginUp::set_useridstr(const char* value) {
  set_has_useridstr();
  if (useridstr_ == &::google::protobuf::internal::kEmptyString) {
    useridstr_ = new ::std::string;
  }
  useridstr_->assign(value);
}
inline void UserLoginUp::set_useridstr(const char* value, size_t size) {
  set_has_useridstr();
  if (useridstr_ == &::google::protobuf::internal::kEmptyString) {
    useridstr_ = new ::std::string;
  }
  useridstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginUp::mutable_useridstr() {
  set_has_useridstr();
  if (useridstr_ == &::google::protobuf::internal::kEmptyString) {
    useridstr_ = new ::std::string;
  }
  return useridstr_;
}
inline ::std::string* UserLoginUp::release_useridstr() {
  clear_has_useridstr();
  if (useridstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = useridstr_;
    useridstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginUp::set_allocated_useridstr(::std::string* useridstr) {
  if (useridstr_ != &::google::protobuf::internal::kEmptyString) {
    delete useridstr_;
  }
  if (useridstr) {
    set_has_useridstr();
    useridstr_ = useridstr;
  } else {
    clear_has_useridstr();
    useridstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 asid = 4;
inline bool UserLoginUp::has_asid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLoginUp::set_has_asid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLoginUp::clear_has_asid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLoginUp::clear_asid() {
  asid_ = 0u;
  clear_has_asid();
}
inline ::google::protobuf::uint32 UserLoginUp::asid() const {
  return asid_;
}
inline void UserLoginUp::set_asid(::google::protobuf::uint32 value) {
  set_has_asid();
  asid_ = value;
}

// -------------------------------------------------------------------

// UserLoginDown

// required uint32 loginState = 1;
inline bool UserLoginDown::has_loginstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginDown::set_has_loginstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginDown::clear_has_loginstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginDown::clear_loginstate() {
  loginstate_ = 0u;
  clear_has_loginstate();
}
inline ::google::protobuf::uint32 UserLoginDown::loginstate() const {
  return loginstate_;
}
inline void UserLoginDown::set_loginstate(::google::protobuf::uint32 value) {
  set_has_loginstate();
  loginstate_ = value;
}

// required string logoutTime = 2;
inline bool UserLoginDown::has_logouttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginDown::set_has_logouttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginDown::clear_has_logouttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginDown::clear_logouttime() {
  if (logouttime_ != &::google::protobuf::internal::kEmptyString) {
    logouttime_->clear();
  }
  clear_has_logouttime();
}
inline const ::std::string& UserLoginDown::logouttime() const {
  return *logouttime_;
}
inline void UserLoginDown::set_logouttime(const ::std::string& value) {
  set_has_logouttime();
  if (logouttime_ == &::google::protobuf::internal::kEmptyString) {
    logouttime_ = new ::std::string;
  }
  logouttime_->assign(value);
}
inline void UserLoginDown::set_logouttime(const char* value) {
  set_has_logouttime();
  if (logouttime_ == &::google::protobuf::internal::kEmptyString) {
    logouttime_ = new ::std::string;
  }
  logouttime_->assign(value);
}
inline void UserLoginDown::set_logouttime(const char* value, size_t size) {
  set_has_logouttime();
  if (logouttime_ == &::google::protobuf::internal::kEmptyString) {
    logouttime_ = new ::std::string;
  }
  logouttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginDown::mutable_logouttime() {
  set_has_logouttime();
  if (logouttime_ == &::google::protobuf::internal::kEmptyString) {
    logouttime_ = new ::std::string;
  }
  return logouttime_;
}
inline ::std::string* UserLoginDown::release_logouttime() {
  clear_has_logouttime();
  if (logouttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logouttime_;
    logouttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginDown::set_allocated_logouttime(::std::string* logouttime) {
  if (logouttime_ != &::google::protobuf::internal::kEmptyString) {
    delete logouttime_;
  }
  if (logouttime) {
    set_has_logouttime();
    logouttime_ = logouttime;
  } else {
    clear_has_logouttime();
    logouttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLogoutUp

// -------------------------------------------------------------------

// GetUserinfoUp

// required string userId = 1;
inline bool GetUserinfoUp::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserinfoUp::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserinfoUp::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserinfoUp::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& GetUserinfoUp::userid() const {
  return *userid_;
}
inline void GetUserinfoUp::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetUserinfoUp::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetUserinfoUp::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserinfoUp::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* GetUserinfoUp::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUserinfoUp::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetUserinfoDown

// required string userId = 1;
inline bool GetUserinfoDown::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserinfoDown::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserinfoDown::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserinfoDown::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& GetUserinfoDown::userid() const {
  return *userid_;
}
inline void GetUserinfoDown::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetUserinfoDown::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void GetUserinfoDown::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUserinfoDown::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* GetUserinfoDown::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetUserinfoDown::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .UserInfoBean userInfoBean = 2;
inline bool GetUserinfoDown::has_userinfobean() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserinfoDown::set_has_userinfobean() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserinfoDown::clear_has_userinfobean() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserinfoDown::clear_userinfobean() {
  if (userinfobean_ != NULL) userinfobean_->::UserInfoBean::Clear();
  clear_has_userinfobean();
}
inline const ::UserInfoBean& GetUserinfoDown::userinfobean() const {
  return userinfobean_ != NULL ? *userinfobean_ : *default_instance_->userinfobean_;
}
inline ::UserInfoBean* GetUserinfoDown::mutable_userinfobean() {
  set_has_userinfobean();
  if (userinfobean_ == NULL) userinfobean_ = new ::UserInfoBean;
  return userinfobean_;
}
inline ::UserInfoBean* GetUserinfoDown::release_userinfobean() {
  clear_has_userinfobean();
  ::UserInfoBean* temp = userinfobean_;
  userinfobean_ = NULL;
  return temp;
}
inline void GetUserinfoDown::set_allocated_userinfobean(::UserInfoBean* userinfobean) {
  delete userinfobean_;
  userinfobean_ = userinfobean;
  if (userinfobean) {
    set_has_userinfobean();
  } else {
    clear_has_userinfobean();
  }
}

// -------------------------------------------------------------------

// ChangeUserNameUp

// required string userName = 1;
inline bool ChangeUserNameUp::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeUserNameUp::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeUserNameUp::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeUserNameUp::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ChangeUserNameUp::username() const {
  return *username_;
}
inline void ChangeUserNameUp::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ChangeUserNameUp::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ChangeUserNameUp::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeUserNameUp::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ChangeUserNameUp::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeUserNameUp::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeUserIconUp

// required uint32 icon = 1;
inline bool ChangeUserIconUp::has_icon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeUserIconUp::set_has_icon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeUserIconUp::clear_has_icon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeUserIconUp::clear_icon() {
  icon_ = 0u;
  clear_has_icon();
}
inline ::google::protobuf::uint32 ChangeUserIconUp::icon() const {
  return icon_;
}
inline void ChangeUserIconUp::set_icon(::google::protobuf::uint32 value) {
  set_has_icon();
  icon_ = value;
}

// -------------------------------------------------------------------

// ChangeUserStateUp

// required string eventState = 1;
inline bool ChangeUserStateUp::has_eventstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeUserStateUp::set_has_eventstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeUserStateUp::clear_has_eventstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeUserStateUp::clear_eventstate() {
  if (eventstate_ != &::google::protobuf::internal::kEmptyString) {
    eventstate_->clear();
  }
  clear_has_eventstate();
}
inline const ::std::string& ChangeUserStateUp::eventstate() const {
  return *eventstate_;
}
inline void ChangeUserStateUp::set_eventstate(const ::std::string& value) {
  set_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    eventstate_ = new ::std::string;
  }
  eventstate_->assign(value);
}
inline void ChangeUserStateUp::set_eventstate(const char* value) {
  set_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    eventstate_ = new ::std::string;
  }
  eventstate_->assign(value);
}
inline void ChangeUserStateUp::set_eventstate(const char* value, size_t size) {
  set_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    eventstate_ = new ::std::string;
  }
  eventstate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeUserStateUp::mutable_eventstate() {
  set_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    eventstate_ = new ::std::string;
  }
  return eventstate_;
}
inline ::std::string* ChangeUserStateUp::release_eventstate() {
  clear_has_eventstate();
  if (eventstate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventstate_;
    eventstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeUserStateUp::set_allocated_eventstate(::std::string* eventstate) {
  if (eventstate_ != &::google::protobuf::internal::kEmptyString) {
    delete eventstate_;
  }
  if (eventstate) {
    set_has_eventstate();
    eventstate_ = eventstate;
  } else {
    clear_has_eventstate();
    eventstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string functionState = 2;
inline bool ChangeUserStateUp::has_functionstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeUserStateUp::set_has_functionstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeUserStateUp::clear_has_functionstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeUserStateUp::clear_functionstate() {
  if (functionstate_ != &::google::protobuf::internal::kEmptyString) {
    functionstate_->clear();
  }
  clear_has_functionstate();
}
inline const ::std::string& ChangeUserStateUp::functionstate() const {
  return *functionstate_;
}
inline void ChangeUserStateUp::set_functionstate(const ::std::string& value) {
  set_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    functionstate_ = new ::std::string;
  }
  functionstate_->assign(value);
}
inline void ChangeUserStateUp::set_functionstate(const char* value) {
  set_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    functionstate_ = new ::std::string;
  }
  functionstate_->assign(value);
}
inline void ChangeUserStateUp::set_functionstate(const char* value, size_t size) {
  set_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    functionstate_ = new ::std::string;
  }
  functionstate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeUserStateUp::mutable_functionstate() {
  set_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    functionstate_ = new ::std::string;
  }
  return functionstate_;
}
inline ::std::string* ChangeUserStateUp::release_functionstate() {
  clear_has_functionstate();
  if (functionstate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = functionstate_;
    functionstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeUserStateUp::set_allocated_functionstate(::std::string* functionstate) {
  if (functionstate_ != &::google::protobuf::internal::kEmptyString) {
    delete functionstate_;
  }
  if (functionstate) {
    set_has_functionstate();
    functionstate_ = functionstate;
  } else {
    clear_has_functionstate();
    functionstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserCommondIdEnum>() {
  return ::UserCommondIdEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_1100000_5fUserMessage_2eproto__INCLUDED
